const { onCall, onRequest } = require("firebase-functions/v2/https");
const admin = require('firebase-admin');
const cors = require('cors')({ origin: true });
const crypto = require('crypto');
const functions = require('firebase-functions');
const { getFirestore, FieldValue } = require('firebase-admin/firestore');
const { initializeApp } = require('firebase-admin/app');


if (!admin.apps.length) {
  initializeApp();
}

const corsConfig = {
  origin: ['http://localhost:5173', 'https://flowgenie.com.br', 'https://dados.ilovedeploy.host'],
  methods: ['POST', 'OPTIONS'],
  credentials: true
};



const allowedOrigins = [
  'http://localhost:5173',
  'https://flowgenie.com.br',
  'https://app.flowgenie.com.br',
  'https://dados.ilovedeploy.host'
];

const commonConfig = {
  region: 'us-central1',
  maxInstances: 10,
  timeoutSeconds: 60,
  minInstances: 0,
  cors: {
    origin: [
      'http://localhost:5173',
      'https://flowgenie.com.br',
      'https://app.flowgenie.com.br',
      'https://dados.ilovedeploy.host'
    ],
    methods: ['POST', 'GET', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'Accept'],
    credentials: true,
    maxAge: 3600
  },
  memory: '256MiB'
};

function calculateEngagementScore(userData, eventType) {
  const baseScore = userData?.engagementScore || 0;
  const scores = {
    send: 0,
    open: 1,
    click: 3
  };
  return baseScore + (scores[eventType] || 0);
}

function getInitialScore(eventType) {
  const scores = {
    send: 0,
    open: 1,
    click: 3
  };
  return scores[eventType] || 0;
}

async function initializeTracking(userId) {
  const userRef = admin.firestore().collection('users').doc(userId);
  const trackingRef = userRef.collection('tracking').doc('stats');
  
  await trackingRef.set({
    totalEmails: 0,
    totalOpens: 0,
    uniqueOpens: 0,
    totalClicks: 0,
    uniqueClicks: 0,
    lastUpdate: admin.firestore.FieldValue.serverTimestamp(),
    createdAt: admin.firestore.FieldValue.serverTimestamp()
  });
}



// Função para processar postback do Payt e criar usuário
exports.paytPostback = onRequest({
  ...commonConfig,
  cors: {
    origin: true,
    methods: ['POST', 'OPTIONS', 'GET'],
    allowedHeaders: ['Content-Type'],
    credentials: true
  }
}, async (req, res) => {
  try {
    // Adicionar logs para debug
    console.log('Request recebido:', {
      method: req.method,
      headers: req.headers,
      body: req.body
    });

    // Permitir requisições OPTIONS para pre-flight
    if (req.method === 'OPTIONS') {
      res.status(204).send('');
      return;
    }

    if (req.method !== 'POST') {
      return res.status(405).json({ error: 'Method Not Allowed' });
    }

    // Verificar se o corpo da requisição existe
    if (!req.body) {
      return res.status(400).json({ error: 'Payload inválido' });
    }

    const {
      status,
      customer,
      reference_id
    } = req.body;

    // Validar dados obrigatórios
    if (!status || !customer || !reference_id) {
      return res.status(400).json({ 
        error: 'Dados obrigatórios faltando',
        required: ['status', 'customer', 'reference_id']
      });
    }

    if (status !== 'approved') {
      console.log(`Pagamento não aprovado. Status: ${status}`);
      return res.status(200).json({ received: true, status: 'not_approved' });
    }

    // Validar dados do customer
    if (!customer.email || !customer.name || !customer.phone) {
      return res.status(400).json({
        error: 'Dados do cliente incompletos',
        required: ['email', 'name', 'phone']
      });
    }

    // Gerar senha aleatória
    const password = generatePassword();

    try {
      // Criar usuário no Authentication
      const userRecord = await admin.auth().createUser({
        email: customer.email,
        password: password,
        displayName: customer.name,
        phoneNumber: customer.phone
      });

      // Gerar pixel ID único
      const pixelId = crypto.randomBytes(16).toString('hex');
      
      // Criar batch para operações
      const batch = admin.firestore().batch();
      
      // Documento principal do usuário
      const userRef = admin.firestore().collection('users').doc(userRecord.uid);
      batch.set(userRef, {
        email: customer.email,
        fullName: customer.name,
        phoneNumber: customer.phone,
        smtpUsername: '',
        smtpPassword: '',
        smtpHost: 'mta.flowgenie.com.br',
        smtpPort: '2525',
        referenceId: reference_id,
        createdAt: admin.firestore.FieldValue.serverTimestamp()
      });

      // Configurar pixel
      const pixelConfigRef = userRef.collection('pixel').doc('config');
      batch.set(pixelConfigRef, {
        pixelId: pixelId,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        status: 'active'
      });

      // Configurar tracking inicial
      const trackingStatsRef = userRef.collection('tracking').doc('stats');
      batch.set(trackingStatsRef, {
        totalEmails: 0,
        totalOpens: 0,
        uniqueOpens: 0,
        totalClicks: 0,
        uniqueClicks: 0,
        lastUpdate: admin.firestore.FieldValue.serverTimestamp()
      });

      // Executar todas as operações
      await batch.commit();

      // Criar documento na coleção mail para disparo do email
      await admin.firestore().collection('mail').add({
        to: customer.email,
        message: {
          subject: "Bem-vindo ao Flow Genie - Suas Credenciais de Acesso",
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <img src="https://firebasestorage.googleapis.com/v0/b/apps-95324.appspot.com/o/logos_apps%2FCaptura_de_tela_2024-12-18_150124-removebg-preview.png?alt=media&token=30283dcb-e784-44a9-8b83-984ed6be2d5b" alt="Flow Genie Logo" style="max-width: 200px; margin: 20px 0;">
              <h1 style="color: #333;">Bem-vindo ao Flow Genie!</h1>
              <p>Seu cadastro foi realizado com sucesso. Abaixo estão suas credenciais de acesso:</p>
              <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; margin: 20px 0;">
                <p><strong>Email:</strong> ${customer.email}</p>
                <p><strong>Senha:</strong> ${password}</p>
              </div>
              <p>Por segurança, recomendamos que você altere sua senha no primeiro acesso.</p>
              <p>Para acessar a plataforma, clique no botão abaixo:</p>
              <a href="https://flowgenie.com.br/login" style="display: inline-block; background: #6366f1; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; margin: 20px 0;">Acessar Flow Genie</a>
              <p>Se precisar de ajuda, entre em contato conosco respondendo este email.</p>
            </div>
          `
        }
      });

      // Log de sucesso
      console.log('Usuário criado com sucesso:', {
        userId: userRecord.uid,
        email: customer.email
      });

      return res.status(200).json({
        received: true,
        status: 'success',
        userId: userRecord.uid,
        pixelId: pixelId
      });

    } catch (error) {
      console.error('Erro ao criar usuário:', error);
      return res.status(400).json({ 
        received: true, 
        status: 'error', 
        message: error.message 
      });
    }
  } catch (error) {
    console.error('Erro ao processar postback:', error);
    return res.status(500).json({ 
      received: true, 
      status: 'error', 
      message: error.message 
    });
  }
});

// Função para gerar senha aleatória
const generatePassword = () => {
  const length = 12;
  const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*";
  let password = "";
  for (let i = 0, n = charset.length; i < length; ++i) {
    password += charset.charAt(Math.floor(Math.random() * n));
  }
  return password;
};

// Função original de tracking (renomeada)
exports.setupUserTracking = onCall({
  ...commonConfig
}, async (context) => {
  try {
    const userId = context.auth?.uid;
    if (!userId) throw new Error('Usuário não autenticado');

    const pixelId = crypto.randomBytes(16).toString('hex');
    const batch = admin.firestore().batch();
    const userRef = admin.firestore().collection('users').doc(userId);

    // Configurar pixel
    const pixelConfigRef = userRef.collection('pixel').doc('config');
    batch.set(pixelConfigRef, {
      pixelId: pixelId,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      status: 'active'
    });

    // Configurar tracking inicial
    const trackingStatsRef = userRef.collection('tracking').doc('stats');
    batch.set(trackingStatsRef, {
      totalEmails: 0,
      totalOpens: 0,
      uniqueOpens: 0,
      totalClicks: 0,
      uniqueClicks: 0,
      lastUpdate: admin.firestore.FieldValue.serverTimestamp()
    });

    await batch.commit();

    return { pixelId };
  } catch (error) {
    console.error('Erro ao configurar tracking:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
});

exports.setupTracking = onCall({
  ...commonConfig,
  cors: {
    origin: ['http://localhost:5173', 'https://flowgenie.com.br', 'https://dados.ilovedeploy.host'],
    methods: ['POST', 'GET', 'OPTIONS'], 
    credentials: true
  }
 }, async (context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'Usuário não autenticado');
  }
 
  try {
    const userId = context.auth.uid;
    const userRef = admin.firestore().collection('users').doc(userId);
    const trackingRef = userRef.collection('tracking').doc('stats');
    const today = new Date().toISOString().split('T')[0];
 
    // Criar ou atualizar documento principal de tracking
    await trackingRef.set({
      totalEmails: 0,
      totalOpens: 0,
      uniqueOpens: 0,
      totalClicks: 0,
      uniqueClicks: 0,
      lastUpdate: admin.firestore.FieldValue.serverTimestamp(),
      createdAt: admin.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
 
    // Criar documento inicial de estatísticas diárias
    const dailyStatsRef = trackingRef.collection('dailyStats').doc(today);
    await dailyStatsRef.set({
      date: today,
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
      opens: admin.firestore.FieldValue.increment(0), // Initialize with 0
      clicks: admin.firestore.FieldValue.increment(0),
      uniqueOpens: 0,
      uniqueClicks: 0,
      lastUpdate: admin.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
 
    return {
      success: true,
      message: 'Tracking configurado com sucesso'
    };
 
  } catch (error) {
    console.error('Erro ao configurar tracking:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
 });


// Função trackEvent atualizada
exports.trackEvent = onRequest({
  region: 'us-central1',
  maxInstances: 10,
  minInstances: 0,
  memory: '256MiB',
  cors: {
    origin: [
      'http://localhost:5173',
      'https://flowgenie.com.br',
      'https://app.flowgenie.com.br',
      'https://dados.ilovedeploy.host',
      'https://ilovedeploy.com'
    ],
    methods: ['GET', 'POST', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Accept', 'Origin'],
    credentials: true,
    maxAge: 3600
  }
}, async (req, res) => {
  try {
    console.log('[TRACKING] Request completo:', { 
      method: req.method, 
      query: req.query,
      headers: req.headers,
      url: req.url,
      path: req.path,
      origin: req.headers.origin
    });

    res.set({
      'Access-Control-Allow-Origin': req.headers.origin || '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Accept, Origin',
      'Access-Control-Allow-Credentials': 'true',
      'Access-Control-Max-Age': '3600'
    });

    if (req.method === 'OPTIONS') {
      return res.status(204).send('');
    }

    const { pid, type, url, email, eid } = req.query;
    
    if (!pid || typeof pid !== 'string' || pid.trim() === '') {
      return res.status(400).json({ error: 'Pixel ID inválido' });
    }
    if (!type || typeof type !== 'string' || !['open', 'click'].includes(type)) {
      return res.status(400).json({ error: 'Tipo de evento inválido' });
    }
    if (!email || typeof email !== 'string' || email.trim() === '') {
      return res.status(400).json({ error: 'Email inválido' });
    }
    if (!eid || typeof eid !== 'string' || eid.trim() === '') {
      return res.status(400).json({ error: 'Campaign ID inválido' });
    }

    const decodedEmail = decodeURIComponent(email);
    const today = new Date().toISOString().split('T')[0];

    const pixelsRef = admin.firestore().collectionGroup('pixel');
    const pixelQuery = await pixelsRef.where('pixelId', '==', pid.trim()).limit(1).get();

    if (pixelQuery.empty) {
      console.error('[TRACKING] Pixel não encontrado:', pid);
      return res.status(404).json({ error: 'Pixel não encontrado' });
    }

    const userId = pixelQuery.docs[0].ref.path.split('/')[1];
    if (!userId) {
      console.error('[TRACKING] User ID inválido para o pixel:', pid);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }

    const db = admin.firestore();
    const campaignRef = db.collection('users').doc(userId).collection('campaigns').doc(eid.trim());
    const statsRef = campaignRef.collection('tracking').doc('stats');
    const dailyStatsRef = statsRef.collection('dailyStats').doc(today);
    const leadsRef = campaignRef.collection('leads').doc(decodedEmail.trim());
    const eventRef = campaignRef.collection('events').doc();

    const campaignDoc = await campaignRef.get();
    if (!campaignDoc.exists) {
      console.error('[TRACKING] Campanha não encontrada:', eid);
      return res.status(404).json({ error: 'Campanha não encontrada' });
    }

    await db.runTransaction(async (transaction) => {
      console.log('[TRACKING] Iniciando transaction');
      
      const leadDoc = await transaction.get(leadsRef);
      const statsDoc = await transaction.get(statsRef);
      const dailyStatsDoc = await transaction.get(dailyStatsRef);
      const leadData = leadDoc.exists ? leadDoc.data() || {} : {};

      const eventData = {
        type,
        email: decodedEmail.trim(),
        campaignId: eid.trim(),
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
        userAgent: req.headers['user-agent'] || '',
        ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress || '',
        metadata: {
          pixelId: pid.trim(),
          url: url ? decodeURIComponent(url) : null
        }
      };

      if (!statsDoc.exists) {
        transaction.set(statsRef, {
          totalEmails: 0,
          totalOpens: 0,
          uniqueOpens: 0,
          totalClicks: 0,
          uniqueClicks: 0,
          lastUpdate: admin.firestore.FieldValue.serverTimestamp()
        });
      }

      if (!dailyStatsDoc.exists) {
        transaction.set(dailyStatsRef, {
          date: today,
          emails: 0,
          opens: 0,
          clicks: 0,
          uniqueOpens: 0,
          uniqueClicks: 0,
          timestamp: admin.firestore.FieldValue.serverTimestamp()
        });
      }

      transaction.set(eventRef, eventData);

      // Mantendo os campos existentes e adicionando/atualizando os novos
      const leadUpdate = {
        email: decodedEmail.trim(),
        firstSeen: leadData.firstSeen || admin.firestore.FieldValue.serverTimestamp(),
        lastActivity: admin.firestore.FieldValue.serverTimestamp(),
        status: leadData.status || 'active',
        metadata: {
          lastUserAgent: eventData.userAgent,
          lastIp: eventData.ip
        },
        hasOpened: type === 'open' ? true : leadData.hasOpened || false,
        hasClicked: type === 'click' ? true : leadData.hasClicked || false,
        totalOpens: type === 'open' ? (leadData.totalOpens || 0) + 1 : (leadData.totalOpens || 0),
        totalClicks: type === 'click' ? (leadData.totalClicks || 0) + 1 : (leadData.totalClicks || 0),
        // Novos campos - preservando valores existentes ou inicializando
        totalEmailsEnviados: leadData.totalEmailsEnviados || 0,
        ultimoEmailEnviado: leadData.ultimoEmailEnviado || null,
        unsubscribe: leadData.unsubscribe || false,
        evento: leadData.evento || null
      };

      if (type === 'open') {
        transaction.update(statsRef, {
          totalOpens: admin.firestore.FieldValue.increment(1),
          uniqueOpens: leadData.hasOpened ? 0 : 1,
          lastUpdate: admin.firestore.FieldValue.serverTimestamp()
        });

        transaction.update(dailyStatsRef, {
          opens: admin.firestore.FieldValue.increment(1),
          uniqueOpens: leadData.hasOpened ? 0 : 1
        });
      } 
      else if (type === 'click') {
        if (url) {
          leadUpdate.lastClickUrl = decodeURIComponent(url);
        }

        transaction.update(statsRef, {
          totalClicks: admin.firestore.FieldValue.increment(1),
          uniqueClicks: leadData.hasClicked ? 0 : 1,
          lastUpdate: admin.firestore.FieldValue.serverTimestamp()
        });

        transaction.update(dailyStatsRef, {
          clicks: admin.firestore.FieldValue.increment(1),
          uniqueClicks: leadData.hasClicked ? 0 : 1
        });
      }

      transaction.set(leadsRef, leadUpdate, { merge: true });
    });

    if (type === 'click' && url) {
      return res.redirect(302, decodeURIComponent(url));
    }

    if (type === 'open') {
      res.set({
        'Content-Type': 'image/gif',
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      });
      return res.send(Buffer.from('R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7', 'base64'));
    }

    return res.status(200).json({ success: true });

  } catch (error) {
    console.error('[TRACKING] Erro crítico:', {
      message: error.message,
      stack: error.stack,
      context: req.query
    });
    return res.status(500).json({ 
      error: 'Erro interno do servidor',
      details: error.message
    });
  }
});

// Função helper para processar evento de abertura
async function handleOpenEvent(transaction, params) {
  const {
    campaignTrackingRef,
    campaignDailyStatsRef,
    campaignLeadsRef,
    decodedEmail,
    eventData
  } = params;

  // Buscar dados existentes do lead
  const leadDoc = await transaction.get(campaignLeadsRef);
  const leadData = leadDoc.exists ? leadDoc.data() : {};

  // Verificar primeira abertura
  const isFirstOpen = !leadData.hasOpened;

  // Atualizar dados do lead
  transaction.set(campaignLeadsRef, {
    email: decodedEmail,
    firstSeen: leadData.firstSeen || admin.firestore.FieldValue.serverTimestamp(),
    lastActivity: admin.firestore.FieldValue.serverTimestamp(),
    totalOpens: admin.firestore.FieldValue.increment(1),
    hasOpened: true,
    lastOpen: admin.firestore.FieldValue.serverTimestamp(),
    status: leadData.status || 'active',
    metadata: {
      ...leadData.metadata,
      lastUserAgent: eventData.userAgent,
      lastIp: eventData.ip
    }
  }, { merge: true });

  if (isFirstOpen) {
    transaction.update(campaignTrackingRef, {
      uniqueOpens: admin.firestore.FieldValue.increment(1),
      totalOpens: admin.firestore.FieldValue.increment(1),
      lastUpdate: admin.firestore.FieldValue.serverTimestamp()
    });

    transaction.set(campaignDailyStatsRef, {
      date: eventData.timestamp,
      opens: admin.firestore.FieldValue.increment(1),
      uniqueOpens: admin.firestore.FieldValue.increment(1),
      timestamp: admin.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
  }
}

// Função helper para processar evento de clique
async function handleClickEvent(transaction, params) {
  const {
    campaignTrackingRef,
    campaignDailyStatsRef,
    campaignLeadsRef,
    decodedEmail,
    eventData,
    url
  } = params;

  const leadDoc = await transaction.get(campaignLeadsRef);
  const leadData = leadDoc.exists ? leadDoc.data() : {};

  const isFirstClick = !leadData.hasClicked;

  transaction.set(campaignLeadsRef, {
    email: decodedEmail,
    firstSeen: leadData.firstSeen || admin.firestore.FieldValue.serverTimestamp(),
    lastActivity: admin.firestore.FieldValue.serverTimestamp(),
    totalClicks: admin.firestore.FieldValue.increment(1),
    hasClicked: true,
    lastClick: admin.firestore.FieldValue.serverTimestamp(),
    lastClickUrl: url,
    status: leadData.status || 'active',
    metadata: {
      ...leadData.metadata,
      lastUserAgent: eventData.userAgent,
      lastIp: eventData.ip
    }
  }, { merge: true });

  if (isFirstClick) {
    transaction.update(campaignTrackingRef, {
      uniqueClicks: admin.firestore.FieldValue.increment(1),
      totalClicks: admin.firestore.FieldValue.increment(1),
      lastUpdate: admin.firestore.FieldValue.serverTimestamp()
    });

    transaction.set(campaignDailyStatsRef, {
      date: eventData.timestamp,
      clicks: admin.firestore.FieldValue.increment(1),
      uniqueClicks: admin.firestore.FieldValue.increment(1),
      timestamp: admin.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
  }
}


// Migration script to populate daily stats
exports.migrateToDailyStats = onRequest({
  ...commonConfig
}, async (req, res) => {
  try {
    // Security check - add your admin token validation here
    const { adminToken } = req.query;
    if (adminToken !== 'YOUR_ADMIN_TOKEN') {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const usersRef = admin.firestore().collection('users');
    const usersSnapshot = await usersRef.get();

    for (const userDoc of usersSnapshot.docs) {
      const userId = userDoc.id;
      console.log(`Processing user: ${userId}`);

      const trackingRef = admin.firestore()
        .collection('users')
        .doc(userId)
        .collection('tracking')
        .doc('stats');

      const eventsRef = trackingRef.collection('events');
      const eventsSnapshot = await eventsRef.orderBy('timestamp').get();

      const dailyStats = new Map();

      // Process all events and group by date
      for (const eventDoc of eventsSnapshot.docs) {
        const event = eventDoc.data();
        if (!event.timestamp) continue;

        const date = event.timestamp.toDate();
        const dateStr = date.toISOString().split('T')[0];
        
        if (!dailyStats.has(dateStr)) {
          dailyStats.set(dateStr, {
            date: dateStr,
            opens: 0,
            clicks: 0,
            uniqueOpens: new Set(),
            uniqueClicks: new Set()
          });
        }

        const stats = dailyStats.get(dateStr);
        if (event.type === 'open') {
          stats.opens++;
          stats.uniqueOpens.add(event.email);
        } else if (event.type === 'click') {
          stats.clicks++;
          stats.uniqueClicks.add(event.email);
        }
      }

      // Convert stats for Firestore and write in batches
      const batch = admin.firestore().batch();
      let operationCount = 0;
      const MAX_BATCH_OPERATIONS = 500;

      for (const [dateStr, stats] of dailyStats) {
        if (operationCount >= MAX_BATCH_OPERATIONS) {
          await batch.commit();
          batch = admin.firestore().batch();
          operationCount = 0;
        }

        const dailyStatsRef = trackingRef.collection('dailyStats').doc(dateStr);
        batch.set(dailyStatsRef, {
          date: dateStr,
          opens: stats.opens,
          clicks: stats.clicks,
          uniqueOpens: stats.uniqueOpens.size,
          uniqueClicks: stats.uniqueClicks.size,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });

        operationCount++;
      }

      if (operationCount > 0) {
        await batch.commit();
      }

      console.log(`Completed processing for user: ${userId}`);
    }

    return res.status(200).json({ 
      success: true, 
      message: 'Migration completed successfully' 
    });

  } catch (error) {
    console.error('Migration error:', error);
    return res.status(500).json({ 
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});


exports.migrateToNewTracking = onRequest({
  ...commonConfig,
  timeoutSeconds: 540 // 9 minutes for large datasets
}, async (req, res) => {
  try {
    if (!req.headers.authorization) {
      return res.status(401).json({ error: 'No authorization header' });
    }

    const token = req.headers.authorization.split('Bearer ')[1];
    try {
      await admin.auth().verifyIdToken(token);
    } catch (error) {
      return res.status(403).json({ error: 'Invalid token' });
    }

    const usersRef = admin.firestore().collection('users');
    const usersSnapshot = await usersRef.get();
    const results = { success: [], errors: [] };

    for (const userDoc of usersSnapshot.docs) {
      const userId = userDoc.id;
      console.log(`Processing user ${userId}`);

      try {
        const eventsRef = admin.firestore()
          .collection('users')
          .doc(userId)
          .collection('tracking')
          .doc('stats')
          .collection('events');

        const eventsSnapshot = await eventsRef.get();
        const dailyStats = new Map();

        // Process all events
        eventsSnapshot.forEach(eventDoc => {
          const event = eventDoc.data();
          if (!event.timestamp) return;

          const date = event.timestamp.toDate();
          const dateKey = date.toISOString().split('T')[0];

          if (!dailyStats.has(dateKey)) {
            dailyStats.set(dateKey, {
              date: dateKey,
              opens: 0,
              clicks: 0,
              uniqueOpens: new Set(),
              uniqueClicks: new Set()
            });
          }

          const stats = dailyStats.get(dateKey);
          if (event.type === 'open') {
            stats.opens++;
            stats.uniqueOpens.add(event.email);
          } else if (event.type === 'click') {
            stats.clicks++;
            stats.uniqueClicks.add(event.email);
          }
        });

        // Write daily stats
        const batch = admin.firestore().batch();
        const statsRef = admin.firestore()
          .collection('users')
          .doc(userId)
          .collection('tracking')
          .doc('stats');

        for (const [dateKey, stats] of dailyStats) {
          const dailyStatsRef = statsRef.collection('dailyStats').doc(dateKey);
          batch.set(dailyStatsRef, {
            date: dateKey,
            opens: stats.opens,
            clicks: stats.clicks,
            uniqueOpens: stats.uniqueOpens.size,
            uniqueClicks: stats.uniqueClicks.size,
            timestamp: admin.firestore.Timestamp.fromDate(new Date(dateKey)),
            updatedAt: admin.firestore.FieldValue.serverTimestamp()
          });
        }

        await batch.commit();
        results.success.push(userId);
        console.log(`Successfully processed user ${userId}`);
      } catch (error) {
        console.error(`Error processing user ${userId}:`, error);
        results.errors.push({ userId, error: error.message });
      }
    }

    return res.status(200).json({
      message: 'Migration completed',
      results
    });

  } catch (error) {
    console.error('Migration error:', error);
    return res.status(500).json({ error: error.message });
  }
});



exports.getInteractionHistory = onCall({
  ...commonConfig
}, async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError(
      'unauthenticated',
      'Usuário não autenticado'
    );
  }

  try {
    const { startDate, endDate, type } = data;
    const userId = context.auth.uid;

    const userRef = admin.firestore().collection('users').doc(userId);
    const interactionsRef = userRef.collection('tracking').doc('stats').collection('interactions');

    let query = interactionsRef;

    if (startDate) {
      const startTimestamp = admin.firestore.Timestamp.fromDate(new Date(startDate));
      query = query.where('timestamp', '>=', startTimestamp);
    }

    if (endDate) {
      const endTimestamp = admin.firestore.Timestamp.fromDate(new Date(endDate));
      query = query.where('timestamp', '<=', endTimestamp);
    }

    if (type) {
      query = query.where('type', '==', type);
    }

    query = query.orderBy('timestamp', 'desc');

    const snapshot = await query.get();

    const interactions = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      interactions.push({
        id: doc.id,
        ...data,
        timestamp: data.timestamp.toDate().toISOString()
      });
    });

    return {
      success: true,
      interactions
    };

  } catch (error) {
    console.error('Erro ao buscar histórico:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
});


// Helper function to generate tracking URLs
exports.generateTrackingUrls = (pixelId, emailId, targetUrl) => {
  const baseUrl = 'https://us-central1-flowgenie-28fe4.cloudfunctions.net/trackEvent';
  const baseParams = `pid=${pixelId}&eid=${emailId}`;
  
  return {
    baseParams,
    click: `${baseUrl}?${baseParams}&type=click&email={{email}}&url=${encodeURIComponent(targetUrl)}`,
    open: `${baseUrl}?${baseParams}&type=open&email={{email}}`,
    emailPlaceholder: '{{email}}',
    url: targetUrl
  };
};

// Função para inicializar tracking para novo usuário
exports.initializeTracking = async (userId) => {
  const batch = admin.firestore().batch();
  const userRef = admin.firestore().collection('users').doc(userId);
  
  const statsRef = userRef.collection('tracking').doc('stats');
  batch.set(statsRef, {
    totalEmails: 0,
    totalOpens: 0,
    uniqueOpens: 0,
    totalClicks: 0,
    uniqueClicks: 0,
    createdAt: admin.firestore.FieldValue.serverTimestamp(),
    lastUpdate: admin.firestore.FieldValue.serverTimestamp()
  }, { merge: true });

  const today = new Date().toISOString().split('T')[0];
  const dailyStatsRef = statsRef.collection('dailyStats').doc(today);
  batch.set(dailyStatsRef, {
    date: today,
    opens: 0,
    clicks: 0,
    uniqueOpens: 0,
    uniqueClicks: 0,
    timestamp: admin.firestore.FieldValue.serverTimestamp()
  }, { merge: true });

  await batch.commit();
};

// Função para atualizar estatísticas quando um email é enviado
exports.handleEmailSent = async (userId, emailData) => {
  if (!emailData.email) {
    console.error('Email não fornecido para tracking');
    return;
  }

  const userRef = admin.firestore().collection('users').doc(userId);
  const leadRef = userRef.collection('leads').doc(emailData.email);
  const trackingRef = userRef.collection('tracking').doc('stats');
  const timestamp = admin.firestore.FieldValue.serverTimestamp();

  const batch = admin.firestore().batch();

  // Adicionando os novos campos ao documento do lead
  batch.set(leadRef, {
    email: emailData.email,
    emailId: emailData.emailId,
    lastEmailSent: timestamp,
    lastActivity: timestamp,
    hasOpened: false,
    hasClicked: false,
    engagementScore: getInitialScore('send'),
    // Novos campos
    totalEmailsEnviados: 1, // Inicializa com 1 quando o documento é criado
    ultimoEmailEnviado: timestamp,
    unsubscribe: false, // Inicializa como false
    evento: null // Inicializa como null
  }, { merge: true });

  batch.set(trackingRef, {
    totalEmails: admin.firestore.FieldValue.increment(1),
    lastEmailSent: timestamp,
    lastUpdate: timestamp
  }, { merge: true });

  await batch.commit();
};


// 3. Webhook para integração com n8n
exports.n8nWebhook = onRequest({
  ...commonConfig,
  cors: true
}, async (req, res) => {
  try {
    const { userId, campaignId, type, customerData } = req.body;

    if (!userId || !campaignId || !type) {
      return res.status(400).json({
        error: 'Dados incompletos',
        required: ['userId', 'campaignId', 'type']
      });
    }

    // Referências do Firestore
    const userRef = admin.firestore().collection('users').doc(userId);
    const trackingStatsRef = userRef.collection('tracking').doc('stats');

    // Usar transação para garantir consistência
    await admin.firestore().runTransaction(async (transaction) => {
      // Buscar dados atuais de tracking
      const trackingDoc = await transaction.get(trackingStatsRef);
      const currentStats = trackingDoc.exists ? trackingDoc.data() : {
        totalEmails: 0,
        totalOpens: 0,
        uniqueOpens: 0,
        totalClicks: 0,
        uniqueClicks: 0
      };

      // Incrementar totalEmails
      transaction.set(trackingStatsRef, {
        ...currentStats,
        totalEmails: (currentStats.totalEmails || 0) + 1,
        lastUpdate: admin.firestore.FieldValue.serverTimestamp()
      }, { merge: true });

      // Atualizar também as estatísticas da campanha
      const campaignRef = userRef.collection('campaigns').doc(campaignId);
      const campaignDoc = await transaction.get(campaignRef);
      if (campaignDoc.exists) {
        const campaignStats = campaignDoc.data().stats || {};
        transaction.update(campaignRef, {
          'stats.totalEmails': (campaignStats.totalEmails || 0) + 1,
          'stats.lastUpdate': admin.firestore.FieldValue.serverTimestamp()
        });
      }
    });

    // Resto do código do webhook...
    const pixelDoc = await userRef.collection('pixel').doc('config').get();
    if (!pixelDoc.exists) {
      return res.status(404).json({ error: 'Pixel não encontrado' });
    }

    // Continuar com o processamento normal do webhook...
    
    return res.status(200).json({
      success: true,
      message: 'Email registrado e contabilizado com sucesso'
    });

  } catch (error) {
    console.error('Erro no webhook:', error);
    return res.status(500).json({ error: error.message });
  }
});

// 2. Função auxiliar para buscar estatísticas de email
exports.getEmailStats = onCall({
  ...commonConfig
}, async (context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'Usuário não autenticado');
  }

  try {
    const userRef = admin.firestore().collection('users').doc(context.auth.uid);
    const statsDoc = await userRef.collection('tracking').doc('stats').get();

    if (!statsDoc.exists) {
      return {
        totalEmails: 0,
        totalOpens: 0,
        uniqueOpens: 0,
        totalClicks: 0,
        uniqueClicks: 0
      };
    }

    return statsDoc.data();
  } catch (error) {
    throw new functions.https.HttpsError('internal', 'Erro ao buscar estatísticas');
  }
});

// 2. Função para processar interações de email
exports.handleEmailInteraction = functions.https.onRequest((req, res) => {
  return cors(req, res, async () => {
    try {
      const { userId, campaignId, type, emailId, customerData } = req.body;
      
      if (!userId || !campaignId || !type) {
        return res.status(400).json({
          error: 'Dados obrigatórios faltando',
          required: ['userId', 'campaignId', 'type']
        });
      }

      const campaignRef = admin.firestore()
        .collection('users')
        .doc(userId)
        .collection('campaigns')
        .doc(campaignId);

      const interactionId = require('crypto').randomUUID();
      
      await admin.firestore().runTransaction(async (transaction) => {
        const campaignDoc = await transaction.get(campaignRef);
        if (!campaignDoc.exists) {
          throw new Error('Campanha não encontrada');
        }
        
        const interactionRef = campaignRef
          .collection('interactions')
          .doc(interactionId);
        
        transaction.set(interactionRef, {
          type,
          emailId,
          customerData,
          timestamp: admin.firestore.FieldValue.serverTimestamp()
        });
        
        const stats = campaignDoc.data().stats || {};
        transaction.update(campaignRef, {
          stats: {
            ...stats,
            [`${type}s`]: (stats[`${type}s`] || 0) + 1,
            lastUpdate: admin.firestore.FieldValue.serverTimestamp()
          }
        });
      });
      
      return res.status(200).json({
        success: true,
        message: 'Interação processada com sucesso',
        interactionId
      });

    } catch (error) {
      console.error('Erro ao processar interação:', error);
      return res.status(500).json({
        error: error.message,
        success: false
      });
    }
  });
});

// 3. Função para verificar pixel
exports.validatePixel = onCall(commonConfig, async (context) => {
  try {
    // Verificar autenticação
    if (!context.auth) {
      throw new Error('Não autorizado: Usuário não autenticado');
    }

    const userId = context.auth.uid;
    console.log('[VALIDATE_PIXEL] Usuário autenticado:', userId);

    // Buscar pixel existente
    const userRef = admin.firestore().collection('users').doc(userId);
    const pixelDoc = await userRef.collection('pixel').doc('config').get();

    if (pixelDoc.exists) {
      console.log('[VALIDATE_PIXEL] Pixel existente encontrado');
      const pixelData = pixelDoc.data();
      
      return { 
        pixelId: pixelData.pixelId,
        isNew: false,
        status: pixelData.status || 'active'
      };
    }

    // Criar novo pixel
    console.log('[VALIDATE_PIXEL] Criando novo pixel');
    const pixelId = crypto.randomBytes(16).toString('hex');
    
    await userRef.collection('pixel').doc('config').set({
      pixelId,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      status: 'active'
    });

    // Inicializar tracking stats se necessário
    const trackingRef = userRef.collection('tracking').doc('stats');
    const trackingDoc = await trackingRef.get();

    if (!trackingDoc.exists) {
      await trackingRef.set({
        totalEmails: 0,
        totalOpens: 0,
        uniqueOpens: 0,
        totalClicks: 0,
        uniqueClicks: 0,
        lastUpdate: admin.firestore.FieldValue.serverTimestamp(),
        createdAt: admin.firestore.FieldValue.serverTimestamp()
      });
    }

    console.log('[VALIDATE_PIXEL] Novo pixel criado com sucesso:', pixelId);
    
    return {
      pixelId,
      isNew: true,
      status: 'active'
    };

  } catch (error) {
    console.error('[VALIDATE_PIXEL] Erro crítico:', {
      errorMessage: error.message,
      errorCode: error.code,
      errorName: error.name,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });

    throw new Error(process.env.NODE_ENV === 'development' ? 
      error.message : 
      'Ocorreu um erro ao processar sua requisição'
    );
  }
});


// Atualizando a função handleEmailSent para incluir os novos campos
exports.handleEmailSent = async (userId, emailData) => {
  if (!emailData.email) {
    console.error('Email não fornecido para tracking');
    return;
  }

  const userRef = admin.firestore().collection('users').doc(userId);
  const leadRef = userRef.collection('leads').doc(emailData.email);
  const trackingRef = userRef.collection('tracking').doc('stats');
  const timestamp = admin.firestore.FieldValue.serverTimestamp();

  const batch = admin.firestore().batch();

  // Adicionando os novos campos ao documento do lead
  batch.set(leadRef, {
    email: emailData.email,
    emailId: emailData.emailId,
    lastEmailSent: timestamp,
    lastActivity: timestamp,
    hasOpened: false,
    hasClicked: false,
    engagementScore: getInitialScore('send'),
    // Novos campos
    totalEmailsEnviados: 1, // Inicializa com 1 quando o documento é criado
    ultimoEmailEnviado: timestamp,
    unsubscribe: false, // Inicializa como false
    evento: null // Inicializa como null
  }, { merge: true });

  batch.set(trackingRef, {
    totalEmails: admin.firestore.FieldValue.increment(1),
    lastEmailSent: timestamp,
    lastUpdate: timestamp
  }, { merge: true });

  await batch.commit();
};

// Atualizando a função trackEmailSent para incluir os novos campos
exports.trackEmailSent = onRequest({
  ...commonConfig,
  cors: {
    origin: ['https://n8n.flowgenie.com.br'],
    methods: ['POST'],
    credentials: true
  }
}, async (req, res) => {
  try {
    console.log('Received request body:', JSON.stringify(req.body, null, 2));

    const { userId, emails } = req.body;

    if (!userId || !emails || !Array.isArray(emails)) {
      console.log('Validation failed:', { userId, emails });
      return res.status(400).json({
        error: 'Payload inválido',
        required: ['userId', 'emails (array)'],
        received: { 
          userId: userId || 'not provided',
          emailsType: emails ? typeof emails : 'not provided',
          isArray: emails ? Array.isArray(emails) : false
        }
      });
    }

    for (const email of emails) {
      if (!email.to || !email.metadata || !email.metadata.campaignId) {
        return res.status(400).json({
          error: 'Estrutura de email inválida',
          required: ['to', 'metadata.campaignId'],
          received: email
        });
      }
    }

    const db = getFirestore();
    const today = new Date().toISOString().split('T')[0];
    
    const emailsByCampaign = emails.reduce((acc, email) => {
      const campaignId = email.metadata.campaignId;
      if (!acc[campaignId]) {
        acc[campaignId] = [];
      }
      acc[campaignId].push(email);
      return acc;
    }, {});

    for (const [campaignId, campaignEmails] of Object.entries(emailsByCampaign)) {
      const totalEmails = campaignEmails.length;
      
      const campaignRef = db
        .collection('users')
        .doc(userId)
        .collection('campaigns')
        .doc(campaignId);
      
      const campaignTrackingRef = campaignRef
        .collection('tracking')
        .doc('stats');
      
      const campaignDailyStatsRef = campaignTrackingRef
        .collection('dailyStats')
        .doc(today);

      // Atualizar documentos de leads com os novos campos
      const batch = db.batch();
      for (const email of campaignEmails) {
        const leadRef = campaignRef.collection('leads').doc(email.to);
        
        // Primeiro, tentar obter o documento existente
        const leadDoc = await leadRef.get();
        const currentTotalEmails = leadDoc.exists ? (leadDoc.data().totalEmailsEnviados || 0) : 0;

        batch.set(leadRef, {
          email: email.to,
          lastActivity: FieldValue.serverTimestamp(),
          // Novos campos e atualizações
          totalEmailsEnviados: currentTotalEmails + 1,
          ultimoEmailEnviado: FieldValue.serverTimestamp(),
          unsubscribe: false,
          evento: email.metadata.evento || null,
          // Manter campos existentes se já existirem
          ...(leadDoc.exists && {
            hasOpened: leadDoc.data().hasOpened || false,
            hasClicked: leadDoc.data().hasClicked || false,
            engagementScore: leadDoc.data().engagementScore || 0
          })
        }, { merge: true });
      }
      await batch.commit();

      // Atualizar estatísticas da campanha
      await db.runTransaction(async (transaction) => {
        const dailyDoc = await transaction.get(campaignDailyStatsRef);
        
        if (!dailyDoc.exists) {
          transaction.set(campaignDailyStatsRef, {
            date: today,
            emails: totalEmails,
            opens: 0,
            clicks: 0,
            uniqueOpens: 0,
            uniqueClicks: 0,
            timestamp: FieldValue.serverTimestamp(),
            lastUpdate: FieldValue.serverTimestamp()
          });
        } else {
          transaction.update(campaignDailyStatsRef, {
            emails: FieldValue.increment(totalEmails),
            lastUpdate: FieldValue.serverTimestamp()
          });
        }

        transaction.set(campaignTrackingRef, {
          totalEmails: FieldValue.increment(totalEmails),
          lastUpdate: FieldValue.serverTimestamp()
        }, { merge: true });
      });

      // Registrar eventos
      const eventsBatch = db.batch();
      const eventsRef = campaignRef.collection('events');

      for (const email of campaignEmails) {
        const eventDoc = eventsRef.doc();
        eventsBatch.set(eventDoc, {
          type: 'send',
          email: email.to,
          timestamp: FieldValue.serverTimestamp(),
          metadata: {
            ...email.metadata,
            source: 'n8n'
          }
        });
      }

      await eventsBatch.commit();
    }

    return res.status(200).json({
      success: true,
      totalProcessed: emails.length,
      date: today
    });

  } catch (error) {
    console.error('Erro ao processar emails:', error);
    console.error({
      message: error.message,
      stack: error.stack,
      code: error.code,
      details: error.details
    });

    return res.status(500).json({ 
      error: error.message,
      code: error.code || 'UNKNOWN_ERROR'
    });
  }
});
